# Process

## 프로세스의 개념

![스크린샷 2023-01-04 오전 10.17.30.png](Process%208f843efc51b7441097cdc3ae2cb118b5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_10.17.30.png)

= 실행중인 프로그램

### 프로세스의 문맥(context)

- cpu 수행 상태를 나타내는 하드웨어 문맥
    - register 가 어떤 값을 가지고 있었는지
- 프로세스의 주소 공간
    - code, data, stack에 어떤 내용이 들어있는가
- 프로세스 관련 커널 자료 구조

커널의 코드가 누구의 부탁을 받고 실행하는지, 프로세스의 cernel stack을 별도로 둔다.

- 특정 시점을 놓고 프로세스가 어디까지 수행했는지 규명하는데 필요한 요소
- 프로세스의 현재상태를 나타내는 모든 요소

## 프로세스의 상태

cpu를 잡고 있는 프로세스는 하나

![스크린샷 2023-01-04 오전 10.35.07.png](Process%208f843efc51b7441097cdc3ae2cb118b5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_10.35.07.png)

- running
    
    cpu를 잡고 인스트럭션 수행중인 상태
    
- ready
    
    cpu를 기다리는 상태
    
- blocked(waiting)
    
    cpu를 줘도 당장 인스트럭션 수행할 수 없는 상태
    
    - 프로세스 자신이 요청한 이벤트가 즉시 만족되지 않아 기다리는 상태 (ex io)
- new
    
    프로세스가 생성중인 상태
    
- terminated
    
    수행이 끝난상태
    

## PCB (process control block)

운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보

![스크린샷 2023-01-04 오전 10.46.10.png](Process%208f843efc51b7441097cdc3ae2cb118b5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_10.46.10.png)

## 문맥교환 (context switch)

cpu를 한 프로세스에서 다른 프로세스로 넘겨주는 과정

![스크린샷 2023-01-04 오전 11.23.46.png](Process%208f843efc51b7441097cdc3ae2cb118b5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.23.46.png)

프로세스의 문멕을 pcb에서 찾아서 스위칭

사용자프로세스간 cpu가 넘어가는 것

![스크린샷 2023-01-04 오전 11.29.57.png](Process%208f843efc51b7441097cdc3ae2cb118b5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.29.57.png)

- System call 이나 interrupt 발생할 때 cpu가 운영체제로 넘어갔다가 다시 이전에 사용하던 프로세스한테 넘겨주는 경우
    
    ⇒ 이건 컨텍스트 스위칭이 아님! (사진의 1번)
    
- 운영체제가 cpu를 이전의 프로세스가 아닌 다른 프로세스로 넘겨주는 경우가 있음. 그건 컨텍스트 스위칭 맞음 (사진의 2번)
    
    ex. timer interrupt, i/o 요청 system call (i/o는 오래걸리니까 이전의 프로세스로 돌아가도 오래걸린다고 판단하여 다른 프로세스로 스위칭된다)
    
    → 이 경우 캐시 메모리 플러시 과정이 발생함.
    

## 프로세스를 스케줄링 하기위한 큐

- Job Queue
    - 현재 시스템 내에 있는 모든 프로세스 큐
- Read Queue
    - 메모리 내에 있으면서 cpu를 잡아서 실행되기를 기다리는 큐
- Device Queues
    - io디바이스마다의 큐

## 스케줄러

- Long-term scheduler(장기 스케줄러, job scheduler)
    - new → ready (admitted) : ready queue로 보낼지 결정
    - 프로세스에 memory를 주는 문제
    - degree of Multiprogramming 을 제어
    - time sharing system 에는 보통 장기 스케줄러가 없음 (무조건 ready)
- Short-term scheduler(단기 스케줄러, CPU scheduler)
    - 어떤 프로세스를 다음번에 running 시킬지 결정
- Medium-term scheduler(중기 스케줄러, Swapper)
    - 프로세스에게서 memory를 뺏는 문제
    - degree of Multiprogramming 을 제어

![스크린샷 2023-01-04 오후 12.05.11.png](Process%208f843efc51b7441097cdc3ae2cb118b5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.05.11.png)

# Thread

프로세스 내부에 cpu 수행 단위가 여러개 있는 겻

![스크린샷 2023-01-04 오후 12.13.33.png](Process%208f843efc51b7441097cdc3ae2cb118b5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.13.33.png)

![스크린샷 2023-01-04 오후 12.25.13.png](Process%208f843efc51b7441097cdc3ae2cb118b5/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.25.13.png)

스레드간 별도로 가지는 공간

- program counter
- registers
- 스레드 stack

프로세스를 별도로 두는 것 보다 프로세스 내에 스레드를 여러가지 두는게 훨씬 가볍다.

스레드 = lightweight process

**장점**

- 하나의 프로세스 안에 여러개 두게 되면 하나가 blocked 상태일 때 동일한 태스크 내의 다른 스레드가 running되어 빠른 처리를 할 수 있다.
    - 네트워크를 통해 웹사이트를 읽어오는 작업 = io 작업
    - 스레드가 하나라면 브라우저 내에서 읽어오는 동안 아무것도 못한다
- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능향상을 얻을 수 있다
- 병렬성을 높일 수 있다 (cpu가 여러개 있는 경우에만 가능)

**장점4가지로 요약**

- 응답성
    - 스레드가 없으면 블락될때 프로세스가 블락된다
    - 스래드가 여러개면 블락된 스레드 대신 다른 스레드를 러닝할 수 있기 때문에 응답성이 높아진다
- 자원 공유
    - 일부 제외 자원공유하기 때문에 자원효율성 높아짐
- 경제성
    - = 속도가 더 빠르다
    - 프로세스를 하나 더 만드는 자체가 오버헤드다
    - 생성은 30배, cpu 스위칭은 5배 차이난다
- 멀티 프로세서 아키텍처 (cpu가 2개이상 인 경우의 장점)
    - 프로세스는 하나지만 여러개 있으면 가각의 스레드가 병렬적으로 일을 할 수 있다