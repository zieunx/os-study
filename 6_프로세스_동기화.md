# Process Synchronization

## 데이터의 접근

![스크린샷 2023-01-10 오후 6.59.45.png](Process%20Synchronization%207ff5d35d253342a7b746b41dd194a0ec/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.59.45.png)

### 경쟁조건

![스크린샷 2023-01-10 오후 7.05.39.png](Process%20Synchronization%207ff5d35d253342a7b746b41dd194a0ec/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.05.39.png)

여러 프로세스들이 동시에 데이터에 접근하는 상황

데이터를 공유하는 클라이언트가 여럿 있는 경우 경쟁조건의 가능성 있음

- 멀티프로세서 시스템 (cpu가 여러개)
- 공유메모리를 사용하는 프로세스를 커널 내부 데이터를 접근하는

### os 에서 race condition 은 언제 발생하는가?

1. 인터럽트 핸들러 vs 커널
    
    ![스크린샷 2023-01-10 오후 7.15.45.png](Process%20Synchronization%207ff5d35d253342a7b746b41dd194a0ec/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.15.45.png)
    
    1. 커널이 count를 증가시킴
        - 메모리 변수 → cpu register
        - 1 증가
        - 다시 메모리에 씀
    2.  인터럽트가 처리 중에 요청이 들어오면 인터럽트 처리로 넘어감
    3.  컨텍스트를 메모리에서 읽어온 이후 시점으로 했기 때문에 count의 값을 처리하고 저장하면 최종적으로 1 증가한 것 만 반영
2. Process가 System call 을 하여 kernel mode 로 수행 중인데 context switch 가 일어나는 경우
    
    ![스크린샷 2023-01-10 오후 7.20.39.png](Process%20Synchronization%207ff5d35d253342a7b746b41dd194a0ec/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.20.39.png)
    
3. Multiprocessor 에서 shared memory 내의 커널 data
    
    ![스크린샷 2023-01-10 오후 7.27.46.png](Process%20Synchronization%207ff5d35d253342a7b746b41dd194a0ec/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-10_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.27.46.png)
    
    - cpu가 여러개일 때
    - 어떤 cpu가 마지막으로 count store 했는가?
    
    [해결방법 1] 한 번에 하나의 cpu만이 커널에 들어갈 수 있게 하는 방법
    
    [해결방법 2] 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock 을 하는 방법
    

## Process Synchronization 문제

<aside>
💡 공유 데이터에 대해 동시에 접근하려고 할 때 데이터의 불일치 문제를 발생시킬 수 있다. 일관성 유지를 위하여 프로세스 간의 실행 순서를 정해주는 메커니즘 필요

</aside>

## The Critical-Section Problem (임계구역)

- = 공유데이터를 접근하는 코드
- 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section 이 존재

→  하나의 프로세스가 critical section에 있을 때 다른 모든 프로세션은 critical section에 들어갈 수 없어야 한다.